<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pytorch模型保存与载入]]></title>
    <url>%2F2018%2F11%2F28%2FPytorch%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98%E4%B8%8E%E8%BD%BD%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Pytorch基础，主要是保存模型数据，载入模型数据 [TOC] pytorch保存数据1234567state=&#123;'net':model.state_dict(),'optimizer':optimizer.state_dict(),'epoch':Epoch&#125;dir='model.pth'torch.save(state,dir)#或者# torch.save(cnn1,'cnn1.pkl') #保存整个网络结构与参数# torch.save(cnn1.state_dict(),'cnn1_params.pkl') #只保存参数 pytorch载入123456789dir='model.pth'state=torch.load(dir)model.load_state_dict(state['net'])optimizer.load_state_dict(state['optimizer'])Epoch=state['epoch']#或者net=Net()net.load_state_dict(torch.load('net.pth'))]]></content>
      <categories>
        <category>python/PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch加载数据集]]></title>
    <url>%2F2018%2F11%2F28%2FPyTorch%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[PyTorch基础，主要是数据的加载和保存 [TOC] Dataset类 在PyTorch中，加载数据集，需要继承torch.utils.data.dataset 中的Dataset类重写方法 12&gt; from torch.utils.data.dataset import Dataset&gt; 12345678class dataset(Dataset): def __init__(self, ...): def __getitem__(self, ...): return (...) def __len__(self, ...): return len(...) 一个读取图像数据集的例子 1234567891011121314151617181920212223242526272829import osfrom PIL import Imageclass DatasetFromjpg(Dataset): def __init__(self, root, transforms=None): """ Args: root (string): 文件路径 transform: transform 操作 """ self.root=root imgs=os.listdir(root) #这里只是加载路径 self.imgs=[os.path.join(root,img) for img in imgs] #list[图片路径] self.transforms = transforms def __getitem__(self, index): #cat.10.jpg/dog.20.jpg #dog-&gt;1 cat-&gt;0 img_path=self.imgs[index] label=1 if 'dog' in img_path.split('/')[-1] else 0 pil=Image.open(img_path) if self.transforms is not None: img_as_tensor = self.transforms(pil) return (img_as_tensor, label) else: img_as_np = np.asarray(pil) return (img_as_np,label) def __len__(self): return len(self.imgs) transforms 针对PIL图片常用函数 12&gt; from torchvision import transforms&gt; 1234567891011#有次序！！！transformations = /transforms.Compose([transforms.Resize(224), #调整大小，保持比例 最小边-224 transforms.CenterCrop(234), #中心裁剪 transforms.RandomCrop, # transforms.RandomSizedCrop, # transforms.Pad #填充 transforms.ToTensor(), transforms.ToPILImage(), transforms.Normalize(mean=[.5,.5,.5],std=[.5,.5,.5]) ]) # 将读取的图片变化 DataLoader类 加载数据 12&gt; from torch.utils.data import DataLoader&gt; 1234567891011121314train_loader=DataLoader(dataset=dataset, batch_size=10, shuffle=True, #乱序 num_workers=2, #CPU多线程 sample #样本抽样 )#DataLoader是一个迭代对象from torchvision.utils import make_grid,save_imagedataiter = iter(train_loader)images,labels=next(dataiter)photos=make_grid(imgs,3) #tensor类型 3*3网格# plt.imshow(photos)save_image(photos,'save_photos.jpg')]]></content>
      <categories>
        <category>python/PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch学习]]></title>
    <url>%2F2018%2F11%2F28%2FPyTorch%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[机器学习基础，主要是简单的创建数组、算数操作、类型转换等 [TOC] 注意123#inplace方式a.add(b) a.add_(b) #会改变自身数据 函数名以_结尾的都是inplace方式 基础操作创建数组123456789101112#创建Tensortensor([list]) 类似np.array的构造函数 ones(*sizes) 全1Tensor zeros(*sizes) 全0Tensor eye(*sizes) 对角线为1，其他为0 arange(s,e,step) 从s到e，步长为step linspace(s,e,steps) 从s到e，均匀切分成steps份 rand/randn(*sizes) 均匀/标准分布 normal(mean,std) 正态分布/均匀分布 randperm(m) 随机排列 #a.size() 是tuple的子类 Tensorlist/numpy123456#Tensor&lt;---&gt;lista.tolist()#Tensor&lt;-----&gt;numpytorch.from_numpya.numpy() 算术操作123456789101112131415161718192021222324252627282930torch.view #=reshapetorch.unsqueeze(d) #增加维度 从0开始torch.squeeze(d) #压缩为1的维度torch.mm #矩阵乘法t #转置 clamp(input, min, max) #超过min和max部分截断 #逐元素操作abs/sqrt/div/exp/fmod/log/pow.. #绝对值/平方根/除法/指数/求余/求幂.. cos/sin/asin/atan2/cosh #相关三角函数 ceil/round/floor/trunc #上取整/四舍五入/下取整/只保留整数部分 sigmod/tanh #激活函数 #归并操作mean/sum/median/mode #均值/和/中位数/众数 norm/dist #范数/距离 std/var #标准差/方差 cumsum/cumprod #累加/累乘 #线性代数trace #对角线元素之和(矩阵的迹) diag #对角线元素 triu/tril #矩阵的上三角/下三角，可指定偏移量 mm/bmm #矩阵乘法，batch的矩阵乘法 addmm/addbmm/addmv/addr/badbmm #矩阵运算 dot/cross #内积/外积 inverse #求逆矩阵 svd #奇异值分解 Tensor类型转换123456789101112131415b=a.type(torch.FloatTensor)a.float()#CPU版torch.FloatTensortorch.DoubleTensortorch.HalfTensor #16 floattorch.ByteTensor #unsigned char torch.CharTensortorch.ShortTensortorch.IntTensortorch.LongTensor#CPU---&gt;GPUtensor.cuda()tensor.cpu() 保存与载入12torch.save(a,'a.pth')torch.loas(a,'a.pth') Variable 123data tensor类型grad 梯度creator 模型相关12345678#针对dropoutmodel.training() #表明在train模式model.eval() #针对测试torch.save(net.state_dict(),'net.pth')net=Net()net.load_state_dict(torch.load('net.pth'))]]></content>
      <categories>
        <category>python/PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sklearn回顾]]></title>
    <url>%2F2018%2F11%2F15%2FSklearn%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[简单回顾了Sklearn的基本操作 Sklearn回顾数据输入1234from sklearn.cross_validation import train_test_splitX_train,X_test,Y_train,Y_test=train_test_split(X,y, train_size=0.7, random_state=1) 交叉验证！图片 12from sklearn.cross_validation import cross_val_scorecross_val_score(model,X,y,cv=5) 混淆矩阵！图片 1234import seaborn as snsfrom sklearn.metrics import confusion_matrixmat=confusion_matrix(Y_test,y_pred)sns.heatmap(mat,square=True,annot=True,cbar=False) 简单线性回归1234567891011121314151617181920212223#导入数据from sklearn.cross_validation import train_test_splitX_train,X_test,y_train,y_test=train_test_split(X,y, train_size=0.7, random_state=1)X_train=X_train.valuesy_train=y_train.values#2.导入模型from sklearn.linear_model import LinearRegressionmodel=LinearRegression(fit_intercept=True) #设置截距#3.模型适配（训练）model.fit(X_train,y_train)#4.可以查看参数矩阵model.coef_,model.intercept_#5.预测y_pred=model.predict(X_test)#6.评估from sklearn.metrics import accuracy_scoreaccuracy_score(y_test,y_pred)#(7.混淆矩阵)from sklearn.metrics import confusion_matrixmat=confusion_matrix(y_test,y_pred)sns.heatmap(mat,square=True,annot=True,cbar=False) 简单高斯贝叶斯 123from sklearn.naive_bayes import GaussianNBmodel=GaussianNB()model.fit(X_train,y_train)]]></content>
      <categories>
        <category>python/Sklearn</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas回顾]]></title>
    <url>%2F2018%2F11%2F13%2FPandas%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[简单回顾了Pandas的基本操作 Pandas回顾[TOC] Series123456789101112131415161718#字典-数组Series=pd.Series([11,12,13,14]) #直接式#Series=pd.Series(&#123;0:11,1:12,2:13,3:14&#125;) #字典式index=[0,1,2,3]Series=pd.Series(data,index=index) #索引Series#index values#0 11#1 12#2 13#3 14#dtype: int64#有index values dtype #数据索引Series.loc 显式从1开始Series.iloc 隐式 从0开始，左闭右开 DataFrame123456789101112131415#字典-Seriesdata=pd.DataFrame(&#123;'col1':Series1, 'col2':Series2 &#125;)data#index col1 col2#Califor 11 12#Flori 12 12#Texas 2 3#有index columns#索引方式data['col1']data.loc[:,'col1':'col2']#data.ix[:3,'col1':'col2'] 索引对齐12345678910111213141516171819202122A=pd.DataFrame# a b#0 2 3#1 4 5B=pd.DataFrame# a b c#0 1 1 1#1 1 1 1#2 1 1 1A.add(B,fill.value=A.stack().mean())#0 3 4 NaN#1 5 6 NaN#2 NaN NaN NaN #NaN=fill.value+ add- sub* mul/ div// floordiv% mod** pow 缺失值1234567891011isnull #返回marknotnull #与isnull相反dropna(axis，how,thresh) #返回剔除缺失值的数据axis=1 #按维度剔除how=all/any #剔除要求thresh=3 #最小数目fillna(method,axis) #返回填充缺失值的数据副本method=ffill/bfill #继承前/后数值来填充axis #继承方向 高维数据多级索引二维Series12345678910#二维Seriesdata=np.random.randn(4)index=[('a',1),('a',2),('b',1),('b',2)] #元组Series=pd.Series(data,index=index)index=pd.MultiIndex.from_tuples(index) #从元组转换# MultiIndex(levels=[['a', 'b'], [1, 2]],# labels=[[0, 0, 1, 1], [0, 1, 0, 1]])Series=Series.reindex(index) #多级索引data=Seires.unstack() #与DataFrame转换 ---stack 高维DataFrame1234567891011121314151617181920#高维DataFrameoridata=np.random.randn(4,6)index=pd.MultiIndex.from_product([['a','b'],[1,2]], names=['level1','level2'])columns=pd.MultiIndex.from_product([['data1','data2','data3'],['temp1','temp2']], names=['label1','label2'])data=pd.DataFrame(data=oridata,index=index,columns=columns) #两个索引的笛卡尔积data# label1 data1 data2 data3# label2 temp1 temp2 temp1 temp2 temp1 temp2#level1 level2#a 1# 2#b 1# 2#数据索引idx=pd.IndexSlicedata.loc[ idx[:,1] ,idx[:,'temp2'] ] 索引操作12345678对DataFrame的操作sort.index() #方法--排序(字典序)对Series的操作unstack(level=0) #---&gt;二维 stack #反操作reset_index(name='level1') #行列转换 数据集操作123456789101112#简单合并pd.concat( ([DataFrame1,DataFrame2]), axis=0 #合并方向 verity_integrity=True #重复索引触发异常 ignore_index=True #创造新的索引 key=['DataFrame1','DataFrame2'] #增加多级索引 join='inner'/'outer' #列名的交集/合集 )#数据库式合并pd.merge([DataFrame1,DataFrame2])]]></content>
      <categories>
        <category>python/Pandas</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib回顾]]></title>
    <url>%2F2018%2F11%2F13%2FMatplotlib%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[简单回顾了Matplotlib的基本操作 Matplotlib回顾开始使用123456789%matplotlib inline#%matploylib notebookimport matplotlib as mplimport matplotlib.pyplot as pltplot.show() #一个session只能使用一次，通常在末行开启fig.savefig('my_photo.png') #保存图片 简易线性图—&gt;颜色/坐标轴/标签12345678910111213141516171819202122232425262728fig=plot.figure()ax=plt.axes()#直线x=np.linspace(0,10,1000)plt.plot(x,np.sin(x))#颜色pltpltpltplt.plot(x,np.sin(x-0)，color='blue')pltpltplt.plot(x,np.sin(x-1),color='g') #rgbcmykpltplt.plot(x,np.sin(x-2),color='0.75') #灰度：0-1plt.plot(x,np.sin(x-3),color='#FFFFDD')#元素plt.plot(x,np.sin(x-0)，linestyle='-')# '-' '--' '-.' ':'#颜色+元素 ‘--g’#坐标轴plt.xlim(-1,1) #正序plt.ylim(10,1) #逆序plt.axis('tight') #自动收缩空白区域#标签titlexlabel ylabellegend 散点图123456789101112131415161718192021222324plt.plot(x,y, 'o' ,color='r') #'o' '.' ',' 'x' '+' 'v' '^' '&lt;' '&gt;' 's' 'd'#一步到位ptl.plot(x,y,'-ok') #直线(-) 圆圈(o) 黑色(k)#配置参数plt.plot(x,y,'-ok', markersize=15, #点大小 linewidth=4, #线宽 markerfacecolor='white', #中心点颜色 markeredgewidth=2 #点边缘 )plt.scatter(x,y,marker='o')#不同颜色深浅的散点图rng=np.random.RandomState(0)x=rng.randn(100)y=rng.randn(100)colors=rng.rand(100)sizes=rng.rand(100)*1000plt.scatter(x,y,c=colors,s=sizes,alpha=0.4,cmap='viridis')plt.colorbar() #颜色栏 三维图像12345678910111213141516x=np.linspace(0,5,50)y=np.linspace(0,5,40)X,Y=np.meshgrid(x,y)Z=np.sin(X)**10+np.cos(10+X*Y)+np.cos(Y)plt.contour(X,Y,Z, 20, #将数据范围等分20 cmap='RdGy' )plt.contourf()#!!!!!!!!!!!!左上角(0,0)plt.imshow(Z, extent=[0,5,0,5], #坐标轴 origin='lower', # cmap='RdGy') 统计特性—-&gt;直方图/联合分布/seaborn123456789101112131415161718192021222324252627282930#一维plt.hist(data, bins=30, normed=True, alpha=0.5, )counts,bin_edges=np.histogram(data,bins=30) #只输出结果#二维plt.hist2dplt.hexbin #正六边形np.histhistogram2dimport seaborn as sns #使用基于matpltlib的高级APIsns.histsns.kdeplot(x,shade=True) #直方图平滑#hist和KDE相结合sns.distplot#二维联合分布sns.jointplot(x,y,kind='kde') #二维kde#sns.jointplot('x','y',data=DataFrame,kind='hex')sns.jointplot(x,y,kind='hex') sns.jointplot(x,y,kind='reg') #带回归的联合分布 #矩阵图 多变量两两关系图sns.pairplot(DataFrame,hue='species',size=2.5)]]></content>
      <categories>
        <category>python/Matplotlib</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy回顾]]></title>
    <url>%2F2018%2F11%2F12%2FNumpy%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[简单回顾了Numpy的基本操作 Numpy回顾[TOC] 创建数组（zeros/arange/random/eye)1234567np.zeros( (2,3),dtype=int ) #onesnp.arange(0,20,2) #步长为2np.random.randn(3,4) #random normal randintnp.eye(2,3) 数组性质（ndim/shape/dtype)123456np.random.seed(0)x=np.random.randn(2,3,3)print('x.ndim: ',x.ndim)print('x.shape: ',x.shape)print('x.dtype: ',x.dtype) 副本与副本copy123456x=np.random.randn(4,5)x1=x[:2,:2]x1[:,:]=666; #非副本,会改变原数组的值x2=x[:2,:2].copy() #副本 数组拼接(concatenate/vstack/hstack)123456x=np.arange(4)y=np.arange(3)z=np.concatenate([x,y]) #np.vstack np.hstack#np.concatenate([x,y],axis=0) 高维拼接 通用算术1234567// #取整除数**%abssin #弧度expm1 #针对小数值log1p #针对小数值 scipy.special统计特性123456789101112sum #对整个数组的聚合sum(axis=0) #对单一维度进行折叠---相当于对合并行prod #积mean #均值std #标准差var #方差argmin #最小值索引 argmaxmedian #中位数percentile #统计值 percentile(a,25)--分位数any #只要有一个为Trueall 布尔运算符12345#逐位&amp;|^ #xor~ 广播123#规则1：两个数组维度不一样，那么小的数组左边补1#规则2：两个数组维度不匹配，则扩展数值=1的维度#否则引发错误 索引123456789101112#下标传递x=[-1,0,1,2,3,4,5]ind=[2,0,1]x[ind]=[1,-1,0]x=[ [0,1,2] [3,4,5] [6,7,8]]row=[0,1,2]col=[2,1,3]x[row,col].shape=(3,) #第一个索引为下标1，第二个索引为下标2#本质是先广播，后取值 排序1234567sort #=sort 默认从小到大sort(x,axis=0) #会丢失数据之间的依赖关系argsort #=sortedpartition #部分排序partition(x,3,axis=0) #前三个位置为最小的三个值]]></content>
      <categories>
        <category>python/Numpy</category>
      </categories>
      <tags>
        <tag>机器学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的衣库]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%88%91%E7%9A%84%E8%A1%A3%E5%BA%93%2F</url>
    <content type="text"><![CDATA[下面是我所拥有的一部分衣服。 内衣+睡衣 1号 2号 3号 4号 5号 6号 短袖 1号 2号 3号 4号 5号 长袖 1号 2号 3号 4号 毛衣 1号 2号 3号 外衣 1号 2号 3号 4号 5号 6号 短裤 1号 2号 3号 4号 长裤 1号 2号 3号 4号 5号 6号]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>衣服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中cout输出格式]]></title>
    <url>%2F2018%2F09%2F18%2FC%2B%2B%E4%B8%ADcout%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C++中cout的日常使用 控制输出格式 ##控制格式输出 使用样例123456789101112#include &lt;iostream&gt; //使用流对象成员函数#include &lt;iomanip&gt;//使用控制符设置using namespace std;int main()&#123; int a = 31; cout.width(8); //使用流对象成员函数 cout.fill(&apos;*&apos;); cout.unsetf(ios::dec); cout.setf(ios::hex); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; setw(8) &lt;&lt; setfill(&apos;*&apos;) &lt;&lt; resetiosflags(ios::dec) &lt;&lt; setiosflags(ios::hex) &lt;&lt; a &lt;&lt; endl; //使用控制符设置&#125; 参考自乌托的博客]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>cout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复习一：语言基础]]></title>
    <url>%2F2018%2F09%2F18%2FC%2B%2B%E5%A4%8D%E4%B9%A0%E4%B8%80%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[算术类型 变量初始化 const|constexpr auto|decltype 类型转换 算术类型 布尔类型 bool 字符类型 char 整数类型 int / long 浮点类型 float / double 用 sizeof求解占用的内存字节数带符号 signed不带符号 unsigned 变量初始化123int count=0; //拷贝初始化int count(0); //直接初始化int count=&#123;0&#125;; //列表初始化 左值和右值 const|constexpr与auto|decltypeconst 常量constexpr 常量表达式12const int size=20；//运行时常量constexpr int limits=size+20;//编译技术时会是一个常数 auto 自动类型说明符decltype 类型指示符123auto x=1.0; //编译时用正确的类型替换autodecltype(ci) x=1; //只定义x为ci的类型，不赋初值decltype(f() ) y=sum; //定义y为f()的返回值类型 类型转换static_cast用于将一种数据类型转换成另一种数据类型，使用格式如下：变量1 = static_cast&lt;变量1数据类型&gt;(另外一种数据类型变量或表达式);123int a = 1;float b;b = static_cast&lt;float&gt;(a); //类似于C语言中的b = (float)a; const_cast去除表达式中的const限定。用于指针、引用、变量123const int i=0;int *j=&amp;i; //错误j=const_cast_&lt;int *&gt;(&amp;i); //正确 dynamic_cast执行派生类指针或引用与基类指针或引用之间的转换。 reinterpret_cast 不常用从字面意思理解是一个“重新解释的类型转换”。也就是说对任意两个类型之间的变量我们都可以个使用reinterpret_cast在他们之间相互转换，无视类型信息。 按位运算符按位与运算符（&amp;）按位或运算符（|）异或运算符（^）取反运算符（~）左移运算符（&lt;&lt;） 右补0右移运算符（&gt;&gt;） 左补0 不同长度的数据进行位运算如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客建站]]></title>
    <url>%2F2018%2F09%2F16%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[写在前面 早就想着用Github用建个个人博客，刚开始试了官方推荐的jekyll，后来发现好多人多用hexo建站。我两个都试过了，觉得还是hexo好用关键是hexo官方有中文文档。 目前的配置是Github部署网站+Hexo建站工具+next主题+HexoEditor编辑器+腾讯云图床 1.下载安装 下载github安装，其中自带了git。 在github官网申请注册帐号，需要用到邮箱，注册后一定要记住三个东西：你的用户名(username)，你的密码(password)，以及你的邮箱(email) 安装Node.js 新建hexo文件夹，打开 Git Bash。接下来的命令均在Git Bash中执行 安装 Hexo : $npm install -g hexo 安装依赖包： $npm install 执行$hexo init 初始化网站这时候用hexo s就能预览效果了 新建Github仓库：仓库名必须为你的Github名.github.io，要不然就不能使用Github Pages服务了。。。 2.配置 SSH 本地生成公钥私钥 $ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 添加公钥到 Github 根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。 登录 Github，右上角 头像 -&gt; Settings —&gt; SSH keys —&gt; Add SSH key。把公钥粘贴到key中，填好title并点击 Add key。 git bash中输入命令$ssh -T git@github.com，选yes，等待片刻可看到成功提示。 3. NexT主题下载 NexT 主题是由 iissnan 大神所制作的一款简洁美观不失逼格的主题。下载方法有以下两种： 进入博客根目录/themes/, 执行$git clone https://github.com/iissnan/hexo-theme-next.git 直接进入上面的链接，在项目主页download zip文件，然后解压到博客根目录/themes/ 文件夹4. 发布使用以下两条命令进行发布，发布成功后可在浏览器中使用你的github名.github.io进入你的博客~ 12$hexo clean$hexo d -g Hexo 常用命令1.本地预览：12$hexo server//或 hexo s//然后打开浏览器输入localhost:4000可以预览博客效果，用于调试 2. 新建文章12$hexo new post &quot;title&quot;//新文章位置：/source/_posts 3. 新建页面1$hexo new page &quot;title&quot; 4. 部署并生成1$hexo d -g 5. 清除生成的文件和缓存1$hexo clean 推荐使用HexoEditor编辑器就不用手打命令了。4. next主题5. HexoEditorHexoEditor下载地址：https://github.com/zhuzhuyule/HexoEditor里面有详细安装说明Tips12//If find Error about download Electron faild ,you can try run thosenpm install -g electron@1.8.1 6. 腾讯云图床参考资料 Hexo3.1.1静态博客搭建指南 NexT使用文档 Hexo官方文档（中文版） Hexo官方文档（中文版）]]></content>
      <categories>
        <category>hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建图床]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[新浪微博相册图片支持外链，速度快，免费。用新浪微博相册可以为博客、写作平台打造一个免费的图床。 也可以使用腾讯云的对象储存，个人实名以后每个月有大量的免费额度，供个人博客使用足够了。 微博做图床 注册微博账号 上传图片到微博相册 获取外链：点击图片-查看大图-右键图片复制图片链接，得到如下链接： 1http://ww1.sinaimg.cn/large/sample.jpg 同时还有其他大小可以选择1234http://ww1.sinaimg.cn/thumbnail/sample.jpg // 缩略图http://ww1.sinaimg.cn/small/sample.jpg // 稍微大点的图http://ww1.sinaimg.cn/bmiddle/sample.jpg // 再大点的图http://ww1.sinaimg.cn/large/sample.jpg // 最大的 推荐使用picgo图库神器上传图片 腾讯云oss做图床 注册腾讯云账号网上也有推荐七牛云做图床的。但是要上传手持身份证照片。我嫌麻烦。腾讯云只用拿微信做个验证就好了。 创建储存桶。注意有两个关键的配置不能忽略存储桶（bucket）访问权限防盗链设置 访问权限访问权限应设置为公有读私有写。因为我们要去读照片嘛。 防盗链把自己的博客地址加进去 使用腾讯云提供的cos客户端上传图片。右键点击获取图片链接。注意：如果没有把本地地址加入白名单，是不能看到预览图的。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
